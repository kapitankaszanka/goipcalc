package ipcalc_test

import (
	"goipcalc/pkg/ipcalc"
	"testing"
)

type testStruct struct {
	rawInput     string
	ip           ipcalc.IP
	expNiceAddr  string
	expFirstAddr []uint16
	expLastAddr  []uint16
}

var testCasesUtils = []testStruct{
	// IPv4 - basic cases
	{
		"192.168.0.0/24",
		ipcalc.IP{
			Addr: []uint16{0xC0A8, 0x0000},
			Mask: []uint16{0xFFFF, 0xFF00},
			Pfx:  24,
		},
		"192.168.0.0",
		[]uint16{0xC0A8, 0x0000},
		[]uint16{0xC0A8, 0x00FF},
	},
	{
		"10.0.0.1/8",
		ipcalc.IP{
			Addr: []uint16{0x0A00, 0x0001},
			Mask: []uint16{0xFF00, 0x0000},
			Pfx:  8,
		},
		"10.0.0.1",
		[]uint16{0x0A00, 0x0000},
		[]uint16{0x0AFF, 0xFFFF},
	},
	{
		"127.0.0.1/32",
		ipcalc.IP{
			Addr: []uint16{0x7F00, 0x0001},
			Mask: []uint16{0xFFFF, 0xFFFF},
			Pfx:  32,
		},
		"127.0.0.1",
		[]uint16{0x7F00, 0x0001},
		[]uint16{0x7F00, 0x0001},
	},
	{
		"0.0.0.0/0",
		ipcalc.IP{
			Addr: []uint16{0x0000, 0x0000},
			Mask: []uint16{0x0000, 0x0000},
			Pfx:  0,
		},
		"0.0.0.0",
		[]uint16{0x0000, 0x0000},
		[]uint16{0xFFFF, 0xFFFF},
	},
	{
		"128.128.128.128/27",
		ipcalc.IP{
			Addr: []uint16{0x8080, 0x8080},
			Mask: []uint16{0xFFFF, 0xFFE0},
			Pfx:  27,
		},
		"128.128.128.128",
		[]uint16{0x8080, 0x8080},
		[]uint16{0x8080, 0x809F},
	},
	{
		"128.128.128.128/7",
		ipcalc.IP{
			Addr: []uint16{0x8080, 0x8080},
			Mask: []uint16{0xFE00, 0x0000},
			Pfx:  7,
		},
		"128.128.128.128",
		[]uint16{0x8000, 0x0000},
		[]uint16{0x81FF, 0xFFFF},
	},
	{
		"128.128.128.128/14",
		ipcalc.IP{
			Addr: []uint16{0x8080, 0x8080},
			Mask: []uint16{0xFFFC, 0x0000},
			Pfx:  14,
		},
		"128.128.128.128",
		[]uint16{0x8080, 0x0000},
		[]uint16{0x8083, 0xFFFF},
	},

	// IPv6 - basic cases
	{
		"2001:db8::1/64",
		ipcalc.IP{
			Addr: []uint16{0x2001, 0x0DB8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001},
			Mask: []uint16{0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000},
			Pfx:  64,
		},
		"2001:db8:0:0:0:0:0:1",
		[]uint16{0x2001, 0x0DB8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
		[]uint16{0x2001, 0x0DB8, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
	},
	{
		"::1/128",
		ipcalc.IP{
			Addr: []uint16{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001},
			Mask: []uint16{0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
			Pfx:  128,
		},
		"0:0:0:0:0:0:0:1",
		[]uint16{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001},
		[]uint16{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001},
	},
	{
		"::/0",
		ipcalc.IP{
			Addr: []uint16{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
			Mask: []uint16{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
			Pfx:  0,
		},
		"0:0:0:0:0:0:0:0",
		[]uint16{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
		[]uint16{0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
	},
	{
		"1234:1234:1234:1234:1234:1234:1234:1234/64",
		ipcalc.IP{
			Addr: []uint16{0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234},
			Mask: []uint16{0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000},
			Pfx:  64,
		},
		"1234:1234:1234:1234:1234:1234:1234:1234",
		[]uint16{0x1234, 0x1234, 0x1234, 0x1234, 0x0000, 0x0000, 0x0000, 0x0000},
		[]uint16{0x1234, 0x1234, 0x1234, 0x1234, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
	},
	{
		"2001:0:0:0:0:0:db8:1/69",
		ipcalc.IP{
			Addr: []uint16{0x2001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0DB8, 0x0001},
			Mask: []uint16{0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xF800, 0x0000, 0x0000, 0x0000},
			Pfx:  69,
		},
		"2001:0:0:0:0:0:db8:1",
		[]uint16{0x2001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
		[]uint16{0x2001, 0x0000, 0x0000, 0x0000, 0x07FF, 0xFFFF, 0xFFFF, 0xFFFF},
	},
	{
		"2001:db8::11/3",
		ipcalc.IP{
			Addr: []uint16{0x2001, 0x0DB8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0011},
			Mask: []uint16{0xE000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
			Pfx:  3,
		},
		"2001:db8:0:0:0:0:0:11",
		[]uint16{0x2000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
		[]uint16{0x3FFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
	},
	{
		"201:0:0:0:bd:13:14:15/35",
		ipcalc.IP{
			Addr: []uint16{0x0201, 0x0000, 0x0000, 0x0000, 0x00BD, 0x0013, 0x0014, 0x0015},
			Mask: []uint16{0xFFFF, 0xFFFF, 0xE000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
			Pfx:  35,
		},
		"201:0:0:0:bd:13:14:15",
		[]uint16{0x0201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
		[]uint16{0x0201, 0x0000, 0x1FFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF},
	},
}

func TestNiceAddr(t *testing.T) {
	for _, tt := range testCasesUtils {
		r := ipcalc.NiceAddr(tt.ip.Addr)
		if tt.expNiceAddr != r {
			t.Errorf("raw %s got %v, want %v", tt.rawInput, r, tt.expNiceAddr)
		}
	}
}

func TestGetFirstAddress(t *testing.T) {
	for _, tt := range testCasesUtils {
		r := tt.ip.GetFirstAddr()
		if !EqualU16(r, tt.expFirstAddr) {
			t.Errorf("first addr raw %s got %x, want %x", tt.rawInput, r, tt.expFirstAddr)
		}
	}
}

func TestGetLastAddress(t *testing.T) {
	for _, tt := range testCasesUtils {
		r := tt.ip.GetLastAddr()
		if !EqualU16(r, tt.expLastAddr) {
			t.Errorf("last addr raw %s got %x, want %x", tt.rawInput, r, tt.expLastAddr)
		}
	}
}
